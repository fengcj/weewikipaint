多线程问题的本质 -- 有序性，可见性，原子性
synchronize的底层实现
volatile的底层实现
无锁算法的底层实现 -- CAS
原子变量的实现
final关键字的新含义
深入理解Java内存模型
指令重排序和内存屏障
顺序一致性和Happens-before规则
一些基本的硬件知识
一些处理同步问题的技术


1)程序控制线程封闭，这个不是一种具体的技术，而是一种设计思路，从设计上把处理一个对象状态的代码都放到一个线程中去，从而避免线程安全的问题。

2)线程必须用指定的方式使用锁，lock动作必须在try块之前调用，如果lock在try里面执行，可能会在取到锁之前抛出异常，导致执行了unlock动作，从而发生错误。

3)死锁意味者系统冻结，最终相关的所有线程都永久地停滞等待。
饥饿则是总有一些线程能够运行，一小部分线程永久停滞等待。
所以无饥饿意味着肯定无死锁。但是无死锁不意味着无饥饿。