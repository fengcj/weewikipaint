day 0925

http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651223017&idx=1&sn=5824fb82f64e2d15b4d1ba8a0c4ff8b5&chksm=bd49aa6d8a3e237ba6a6a033d2b8e74132c70b4bb9546cc7382cdeab5b1014b535e1ff9d032e&scene=0#wechat_redirect

http://www.erichain.me/front-end/2016/09/05/how-to-implement-responsive-font-size.html

【第701期】如何实现 font-size 的响应式

方案：

我们需要做的主要有以下两点：

1、制定一个最大的和最小的屏幕宽度值，我们的 font-size 应该是在这个屏幕范围内平滑均匀的变化；

不可能让字体大小一直不停的变化。试想一下，自己一直缩小或者方法浏览器，字体一直变小或者变大的场景。

2、制定最大和最小的 font-size，屏幕大小小于最小的屏幕宽度值的时候，应用最小的 font-size，反之，应用最大的 font-size；

依赖：

1. @media
2. vw 单位 Viewport
3. calc function


注意：
1.rem 来定义我们的字体


// 文章中的图片说明很好





=========================================

http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651222835&idx=1&sn=2dec95e50455c4457467f7b86c0ddc09&scene=21#wechat_redirect

https://segmentfault.com/a/1190000006734430

【第688期】在 CSS 中使用功能查询

主题：  @supports  // 以前没见过这个
功能： 判断浏览器是否支持某个属性或者属性对应的值


什么时候才需要使用 @supports 呢？功能查询是将 CSS 声明绑定在一起的一个工具，以便于这些 CSS 规则能够在某种条件下以一个组合的方式运行。当你需要混合使用 CSS 的新规则和旧规则的时候，并且，仅当 CSS 新功能被支持的时候，就可以使用功能查询了。


why use:

多年以来，开发者们都在使用 Modernizr 来实现功能查询，但是 Modernizr 需要 JavaScript。虽然这部分 JavaScript 很小，但是，CSS 结构中添加了 Modernizr 的话，在 CSS 被应用之前，就需要下载 JavaScript 然后等待执行完成。比起使用 CSS，加入了 JavaScript 总是会更慢。而且，要是 JavaScript 执行失败了呢？另外，Modernizr 还需要一层额外复杂的、很多项目都无法理解的东西。相比之下，功能查询更快，功能更强大，使用起来更简单。


=============================================

http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651222899&idx=1&sn=c635c419bc53be0217f58f5ef7f184dd&scene=0#wechat_redirect

http://yanhaijing.com/program/2016/09/01/about-coupling/

【第693期】图解7种耦合关系

//   code写的少，脑子里知道要高内聚，低耦合，但是实际项目中，还是难做到。




=====================

纯 CSS3 后台面板

http://justclear.github.io/pure-css3-backend-panel/?utm_source=tuicool&utm_medium=referral


1. div + p  //  选择紧接在 <div> 元素之后的所有 <p> 元素。
2. p ~ ul  //  选择前面有 <p> 元素的每个 <ul> 元素
3. transition all .5s;


这里需要提一下的是，鼠标点击选项卡的时候，点击的是单选按钮，而不是选项卡 span，然后通过判断 :checked 和使用 + 兄弟元素选择器设置选项卡被选中时的样式，而我们可以通过隐藏单选按钮来实现鼠标点击的是选项卡而不是单选按钮的错觉，而隐藏单选按钮的方法有很多，比如把它的 display 属性值设置为 none，或者 visibility 的值设置为 hidden 等等，但在这里这些方法都不能用，注意我们是要通过对单选按钮的操作来实现我们想要的效果的，所以隐藏之后必须还能对其进行操作，所以在这里我们可以设置它的透明度为 0 来隐藏它。

//  总结，没有使用js去实现tab的切换，而是使用了纯粹的css完成的；关键是：
整体思路是对 type 为 radio 的 input （也就是单选按钮）使用 :checked 选择器，通过它来判断这个单选按钮是否被选中，如果单选按钮的 :checked 的值为 true ，则通过使用 ~ 选择器对单选按钮的同级元素（必须在文档流中处于单选按钮的后面）进行样式设置。

*****  页面布局的学习



===============================

http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651223062&idx=1&sn=0ce46d375f7b5da36e13710ee7744d6e&chksm=bd49ad928a3e248437e47e6a1768849e99aafb77e22af4bff80d9db108ae51e4b374340eb515&scene=0#wechat_redirect

【第703期】优秀的JavaScript模块是怎样炼成的


1. 对于具备众多坑爹问题的JavaScript语言而言，找到一个目标并非难事。典型的例子如：jQuery专注解决DOM操作和Ajax、Underscore专注对象和集合的操作、QUnit和Jasmine专注BDD和TDD的单元测试、moment模块专注解决从Java那里学过来的Date的问题；拿近一些的例子，玉伯的SeaJS专注模块加载，老赵的Wind.js专注异步编程同步化来解决流程控制问题；拿一个有趣的例子，PNGDrivehttps://github.com/MadeInHaus/PNGDrive这个项目虽然没有什么实际用处，但是将文件编码为图片显示出来的方式足够有趣。

2. jQuery兼容各种浏览器的DOM操作这个目标，在移动平台上变得没有意义，所以存在着Zepto.js这样的项目。更小的目标意味着模块自身简洁，且能够更专注，目标更容易抵达。一旦抵达目标，该模块就是稳定的，未来被替换的机会极小。

3. 评判一个模块是否完美，不是可以添加API，而是无法再减少API了。

* try jQuery UI组件



===========================

http://www.imooc.com/article/2397    // 介绍各种前端的生成工具


==========================


【第694期】理解JSX和组件

http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651222930&idx=2&sn=350f0c34f869bb166d6ffb1c2a4f6179&chksm=bd49aa168a3e230037a3b3170be2ae4a67e1adef1da18c8af08dfcc519b8c85cc440c00a22d3&scene=0#wechat_redirect

http://www.infoq.com/cn/articles/react-jsx-and-component/


1. JSX这种混合使用JavaScript和XML的语言第一眼看上去很“丑”，也很神奇，但是其语法和背后的逻辑却极其简单。

2. React的核心机制之一就是虚拟DOM：可以在内存中创建的虚拟DOM元素。React利用虚拟DOM来减少对实际DOM的操作从而提升性能。

3. 将XML语法直接加入到JavaScript代码中，让你能够高效的通过代码而不是模板来定义界面。之后JSX通过翻译器转换到纯JavaScript再由浏览器执行。在实际开发中，JSX在产品打包阶段都已经编译成纯JavaScript，JSX的语法不会带来任何性能影响。另外，由于JSX只是一种语法，因此JavaScript的关键字class, for等也不能出现在XML中，而要如例子中所示，使用className, htmlFor代替，这和原生DOM在JavaScript中的创建也是一致的。

4. 如果说掌握一种模板语言并不是很大的问题，那么其实由模板带来的架构复杂性则是让框架也变得复杂的重要原因之一，例如：
模板需要对应数据模型，即上下文，如何去绑定和实现？
模板可以嵌套，不同部分界面可能来自不同数据模型，如何处理？
模板语言终究是一个轻量级语言，为了满足项目需求，你很可能需要扩展模板引擎的功能。

JSX解决问题的思路：
为了解决这些复杂度，框架本身需要精心的设计，以及创造新的概念（例如Angular的Directive）。这些都会让框架变得复杂和难以掌握，不仅增加了开发成本，各种难以调试的Bug还会降低开发质量。

正因为如此，React直接放弃了模板而发明了JSX。看上去很像模板语言，但其本质是通过代码来构建界面，这使得我们不再需要掌握一门新的语言就可以直观的去定义用户界面：掌握了JavaScript就已经掌握了JSX。

SX完美利用了JavaScript自带的语法和特性，我们只要记住HTML只是代码创建DOM的一种语法形式，就很容易理解JSX。而这种使用代码构建界面的方式，完全消除了业务逻辑和界面元素之间的隔阂，让代码更加直观和易于维护。

5. 事件绑定：
和原生HTML定义事件的唯一区别就是JSX采用驼峰写法来描述事件名称，大括号中仍然是标准的JavaScript表达式，返回一个事件处理函数。在JSX中你不需要关心什么时机去移除事件绑定，因为React会在对应的真实DOM节点移除时就自动解除了事件绑定。

React并不会真正的绑定事件到每一个具体的元素上，而是采用事件代理的模式：

“在根节点document上为每种事件添加唯一的Listener，然后通过事件的target找到真实的触发元素。这样从触发元素到顶层节点之间的所有节点如果有绑定这个事件，React都会触发对应的事件处理函数。这就是所谓的React模拟事件系统。”

尽管整个事件系统由React管理，但是其API和使用方法与原生事件一致。这种机制确保了跨浏览器的一致性：在所有浏览器（IE8及以上）都可以使用符合W3C标准的API，包括stopPropagation()，preventDefault()等等。对于事件的冒泡（bubble）和捕获（capture）模式也都完全支持。

6. CSS样式

尽管在大部分场景下我们应该将样式写在独立的CSS文件中，但是有时对于某个特定组件而言，其样式相当简单而且独立，那么也可以将其直接定义在JSX中。在JSX中使用样式和真实的样式也很类似，通过style属性来定义，但和真实DOM不同的是，“属性值不能是字符串而必须为对象”。

在JSX中可以使用所有的的样式，基本上属性名的转换规范就是将其写成驼峰写法，例如“background-color”变为“backgroundColor”, “font-size”变为“fontSize”，这和标准的JavaScript操作DOM样式的API是一致的。

7. 自定义组件：

在JSX中，我们不仅可以使用React自带div, input...这些虚拟DOM元素，还可以自定义组件。组件定义之后，也都可以利用XML语法去声明，而能够使用的XML Tag就是在当前JavaScript上下文的变量名，这一点非常好用，你不必再去考虑某个Tag是如何对应到相应的组件实现。

8. 生命周期：

React使用组件来封装界面模块，整个界面就是一个大组件，开发过程就是不断优化和拆分界面组件、构造整个组件树的过程。可以认为组件类似于其他框架中Widget（或Control）的概念，但又有所不同。React中的界面一切皆为组件，而Widget一般只是嵌入到界面中为完成某个功能的独立模块。


组件自身定义了一组props作为对外接口，展示一个组件时只需要指定props作为XML节点的属性。组件很少需要对外公开方法，唯一的交互途径就是props。这使得使用组件就像使用函数一样简单，给定一个输入，组件给定一个界面输出。当给予的参数一定时，那么输出也是一定的。而传统控件通常提供很多方法让你在外部改变控件的状态和行为，当控件的状态在不同场景不同逻辑中可以被随意控制时，开发和调试也会变得复杂。

而React组件通过唯一的props接口避免了逻辑复杂性，让开发测试都更加容易。这种特性完全得益于虚拟DOM机制，让你可以每次props改变都能以整体刷新页面的思路去考虑界面展现逻辑。

如果整个项目完全采用React，那么界面上就只有一个组件根节点；如果局部使用React，那么每个局部使用的部分都有一个根节点。在Render时，根节点由React.render函数去触发：


而所有的子节点则都是通过父节点的render方法去构造的。每个组件都会有一个render方法，这个方法返回组件的实例，最终整个界面得到一个虚拟DOM树，再由React以最高效的方式展现在界面上。


除了props之外，组件还有一个很重要的概念：state。组件规范中定义了setState方法，每次调用时都会更新组件的状态，触发render方法。需要注意，render方法是被异步调用的，这可以保证同步的多个setState方法只会触发一次render，有利于提高性能。和props不同，state是组件的内部状态，除了初始化时可能由props来决定，之后就完全由组件自身去维护。在组件的整个生命周期中，React强烈不推荐去修改自身的props，因为这会破坏UI和Model的一致性，props只能够由使用者来决定。


对于自定义组件，唯一必须实现的方法就是render()，除此之外，还有一些方法会在组件生命周期中被调用，如下图所示：


图中的方法几乎已经包括了React的所有API，自定义组件时根据需要在组件生命周期的不同阶段实现不同的逻辑。除了必须的render方法之外，其它常用的方法包括：

componentDidMount: 在组件第一次render之后调用，这时组件对应的DOM节点已被加入到浏览器。在这个方法里可以去实现一些初始化逻辑。
shouldComponentUpdate: 这是一个和性能非常相关的方法，在每一次render方法之前被调用。它提供了一个机会让你决定是否要对组件进行实际的render。例如：
	当此函数返回false时，组件就不会调用render方法从而避免了虚拟DOM的创建和内存中的Diff比较，从而有助于提高性能。当返回true时，则会进行正常的render的逻辑。

组件是React的核心，虽然功能很强大，但是其API和概念却十分简单，以至于你只要实现一个render方法就可以创建一个组件。这大大降低了React学习门槛。


9. 使用Babel进行JSX编译

React JS和React Native已经全部采用第三方Babel的JSX编译器实现。原因是两者在功能上已经完全重复，而Babel作为专门的JavaScript语法编译工具，提供了更为强大的功能。在这里笔者也不得不感叹Facebook的胸怀，以非常开放的态度去拥抱开源社区，从而达到共赢的目的。

JSX是一种新的语法，浏览器并不能直接运行，因此需要这种翻译器。在上一篇文章中我们推荐使用Webpack进行React的开发，要将JSX的编译器从JSTransform切换到Babel非常简单，首先通过npm安装Babel：


只需稍微改变一下webpack.config.js的配置，将原来的jsx-loader变为babel-loader：


10. 总结

本文主要介绍了React中最重要的组件机制，以及声明组件的语法JSX。看似有点神秘的JSX背后的原理非常简单：只是一种用于创建组件的XML语法。让代码直观易懂是软件项目质量的重要保证之一，这意味着代码更加容易理解和维护，出现Bug时更容易调试和修复。因此React这种采用JSX语法，以声明式的方法来直观的定义用户界面的方式，正是其最大的价值。

整个组件机制运行的基础是虚拟DOM，正因为React能够以极高的性能去比较两个虚拟DOM树的Diff，才实现了每次局部更新都通过刷新整个页面这种思考模式，降低了开发复杂度。



============================================

http://www.infoq.com/cn/articles/react-art-of-simplity

深入浅出React（一）：React的设计哲学 - 简单之美

1. React最初来自Facebook内部的广告系统项目，项目实施过程中前端开发遇到了巨大挑战，代码变得越来越臃肿且混乱不堪，难以维护。于是痛定思痛，他们决定抛开很多所谓的“最佳实践”，重新思考前端界面的构建方式，于是就有了React。

// 最佳实践不一定真的合适每个项目

2. 表面上看自动绑定给开发带来了便利，而Facebook却认为这破坏了JavaScript的语言习惯，其背后的神奇（Magic）逻辑或许会给初学者带来困惑，甚至开发者如果从React再转到其它库也可能会无所适从。基于同样的理由，React还取消了对mixin的支持，基于ES6的React组件不再能够以mixin的形式进行代码复用或者扩展。尽管这带来了很大不便，但Facebook认为mixin增加了代码的不可预测性，无法直观的去理解。

// 针对自己的项目做减法，真的不容易。

以简单直观、符合习惯的（idiomatic）方式去编程，让代码更容易被理解，从而易于维护和不断演进。这正是React的设计哲学。


在年初的React开发者大会上，React项目经理Tom Occhino进一步阐述React诞生的初衷，在演讲中提到，React最大的价值究竟是什么？是高性能虚拟DOM、服务器端Render、封装过的事件机制、还是完善的错误提示信息？尽管每一点都足以重要。但他指出，其实React最有价值的是声明式的，“直观的编程方式”。

软件工程向来不提倡用高深莫测的技巧去编程，相反，如何写出可理解可维护的代码才是质量和效率的关键。试想，一个月之后你回头看你写的代码，是否一眼就明白某个变量，某个if判断的含义；一个新加入的同事想去增加一个小小的新功能或是修复某个Bug，他是否对自己的代码有足够的信心不引入任何副作用？随着功能的增加，代码很容易变得越来越复杂，这些问题也将越来越严重，最终导致一份难以维护的代码。而React号称，新同事甚至在加入的第一天就能开始开发新功能。

// 没事别去搞些奇巧淫技，尤其是js这种有很多坑的，很容易陷进去。

3. JSX 直接定义界面

将HTML直接嵌入到JavaScript代码中看上去确实是一件足够疯狂的事情。人们花了多年时间总结出的界面和业务逻辑相互分离的“最佳实践”就这么被彻底打破。那么React为何要如此另类？

模板出现的初衷是让非开发人员也能对界面做一定的修改。但这个初衷在当前Web程序里已完全不适用，每个模板背后的代码逻辑严重依赖模板中的内容和DOM结构，两者是紧密耦合的。即使做到文件位置的分离，实际上两者还是一体的，并且为了两者之间的协作而不得不引入很多机制和概念。

React，在这里你可以利用熟悉的JavaScript语法去定义界面，在你的思维过程中其实已经不需要存在模板的概念，需要考虑的仅仅是如何用代码构建整个界面。这种自然而直观的方式直接降低了React的学习门槛并且让代码更容易理解。

在这里你可以利用熟悉的JavaScript语法去定义界面，在你的思维过程中其实已经不需要存在模板的概念，需要考虑的仅仅是“如何用代码构建整个界面”。这种自然而直观的方式直接降低了React的学习门槛并且让代码更容易理解。


4. 组件即为状态机

所谓组件，就是状态机器

React将用户界面看做简单的状态机器。当组件处于某个状态时，那么就输出这个状态对应的界面。通过这种方式，就很容易去保证界面的一致性。

在React中，你简单的去更新某个组件的状态，然后输出基于新状态的整个界面。React负责以最高效的方式去比较两个界面并更新DOM树。


组件是React中构建用户界面的基本单位。它们和外界的交互除了状态（state）之外，还有就是属性（props）。事实上，状态更多的是一个组件内部去自己维护，而属性则由外部在初始化这个组件时传递进来（一般是组件需要管理的数据）。React认为属性应该是只读的，一旦赋值过去后就不应该变化。关于状态和属性的使用在后续文章中还会深入探讨。


5. 整理刷新

数据模型驱动UI界面的两层编程模型从概念角度看上去是直观的，而在实际开发中却困难重重。一个数据模型的变化可能导致分散在界面多个角落的UI同时发生变化。界面越复杂，这种数据和界面的一致性越难维护。在Facebook内部他们称之为“Cascading Updates”，即层叠式更新，意味着UI界面之间会有一种互相依赖的关系。开发者为了维护这种依赖更新，有时不得不触发大范围的界面刷新，而其中很多并不真的需要。React的初衷之一就是，既然整体刷新一定能解决层叠更新的问题，那我们为什么不索性就每次都这么做呢？让框架自身去解决哪些局部UI需要更新的问题。这听上去非常有挑战，但React却做到了，实现途径就是通过虚拟DOM（Virtual DOM）。


虚拟DOM原理：

UI界面是一棵DOM树，对应的我们创建一个全局唯一的数据模型，每次数据模型有任何变化，都将整个数据模型应用到UI DOM树上，由React来负责去更新需要更新的界面部分。事实证明，这种方式不但简化了开发逻辑并且极大的提高了性能

//  Facebook  自己的案例：  https://www.youtube.com/watch?v=KVZ-P-ZI6W4#t=533


6. 单向数据流动：Flux

既然已经有了组件机制去定义界面，那么还需要一定的机制来定义组件之间，以及组件和数据模型之间如何通信。为此，Facebook提出了Flux框架用于管理数据流。Flux是一个相当宽松的概念框架，同样符合React简单直观的原则。不同于其它大多数MVC框架的双向数据绑定，Flux提倡的是单向数据流动，即永远只有从模型到视图的数据流动。


//  文章有具体流程图


Flux引入了Dispatcher和Action的概念：Dispatcher是一个全局的分发器负责接收Action，而Store可以在Dispatcher上监听到Action并做出相应的操作。简单的理解可以认为类似于全局的消息发布订阅模型。Action可以来自于用户的某个界面操作，比如点击提交按钮；也可以来自服务器端的某个数据更新。当数据模型发生变化时，就触发刷新整个界面。

Flux的定义非常宽松，除了Facebook自己的实现之外，社区中还出现了很多Flux的不同实现，各有特点，比较流行的包括Flexible, Reflux, Flummox等等。


7. 让数据模型也变简单：Immutability

Immutability含义是只读数据，React提倡使用只读数据来建立数据模型。这又是一个听上去相当疯狂的机制：所有数据都是只读的，如果需要修改它，那么你只能产生一份包含新的修改的数据。


只读数据并不是Facebook的全新发明，而是起源于Clojure, Scala, Haskell等函数式编程语言。只读的数据可以让代码更加的安全和易于维护，你不再需要担心数据在某个角落被某段神奇的代码所修改；也就不必再为了找到修改的地方而苦苦调试。而结合React，只读数据能够让React的组件仅仅通过比较对象引用是否相等来决定自身是否要重新Render。这在复杂的界面上可以极大的提高性能。

8. React思想的衍生：React Native, React Canvas



=====================

继续学习的有：
1)ES6
http://es6.ruanyifeng.com/     
2) react and redux
http://www.infoq.com/cn/author/%E7%8E%8B%E6%B2%9B
http://www.ruanyifeng.com/blog/2016/09/react-technology-stack.html
https://egghead.io/lessons/javascript-redux-pure-and-impure-functions
https://facebook.github.io/react/docs/conferences.html
3）css
https://segmentfault.com/a/1190000006913661  // 居中



